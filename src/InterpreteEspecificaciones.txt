OBJETIVO
--------
Construir un intérprete para el Lenguaje de Programación P

DECISIONES DISEÑO
-----------------
(DECISION 1) Cada localización del programa tiene tres secciones dedicada a
declaracion de variables, declaracion de subprogramas y la declaracion de instrucciones

 almacen_variables = conjunto de variables.
 almacen_subprogramas = conjunto de variables e instrucciones
 almacen_instrucciones = consjunto de variables y subprogramas

PROGRAMA
VARIABLES
    i,max,min:NUM;          almacen_variables = {(i,NUM),(max, NUM), (min,NUM), (b,LOG)}
    s:SEQ(NUM);             almacen_variables = {(s,SEQ(NUM)),(s,SEQ(LOG))}
SUBPROGRAMAS
    //pre: cierto
    //post: max es el elemento máximo de s e i es la posición en la que
    // se encuentra.
    FUNCION mayor(SEQ(NUM) s) dev (NUM i, NUM max) alamacen_subprograma =
    VARIABLES
        j: NUM;             alamacen_variables_subprogramas = {(),{()}}
    INSTRUCCIONES           alamacen_instrucciones =
        j=0;
        max=s[j];
        mientras(j<=ultima_posicion(s)) hacer
            si (s[j]>max) entonces
                max=s[j];
                i=j;
            fsi
            j=j+1;
        fmientras
        dev max,i; //retorno de parámetros de salida.
    FFUNCION
INSTRUCCIONES
    { cierto }
    s=[3,4,2,7,9,0,11];
    i=0;
    mostrar(i);
    min=s[i];
    max=s[i];
    mientras (i<=ultima_posicion(s)) hacer
        si (s[i]>max) entonces
            max=s[i];
        fsi
        si (s[i]<min) entonces
            min=s[i];
        fsi
        mostrar(min,max);
        { PARATODO(p:[0,i],s[p]<=max && s[p]>=min) }
        i=i+1;
    fmientras
    { PARATODO(p:[0,ultima_posicion(s)],s[p]<=max && s[p]>=min) }

(DECISION 2) Interpretar(programa) = interpretar secuencialmente sus
 instrucciones.

 Gramática atribuida resultante:
  ------------------------------
  almacen_variables (global)
  almacen_subprogramas
    almacen_variables_subprogrmas(local)
  almacen_instrucciones

  programa: PROGRAMA variables subprogramas instrucciones EOF;

  variables: VARIABLES (declaracion_variables)*;
  subprogramas: SUBPROGRAMAS (declaracion_subprogramas)*;
  instrucciones: INSTRUCCIONES (declaracion_instrucciones)*;

  //---VARIABLES---

  declaracion_variables: identificador PyC;

  identificador: elementales
               | secuencias
               ;

  elementales: (VAR COMA)* VAR DOSPTOS tipos_elementales;

  secuencias: VAR DOSPTOS tipos_no_elementales;

  tipos: tipos_elementales
       | tipos_no_elementales
       ;

  tipos_elementales: NUMERO
                   | BOOL
                   ;

  tipos_no_elementales: SEQ_NUM
                      | SEQ_BOOL
                      ;

  //---SUBPROGRAMAS---
  variable: VAR;

  declaracion_subprogramas: funcion
                          | procedimiento
                          ;

  funcion: FUNCION variable PA (params)? PC RETURN PA params PC variables instrucciones FFUNCION;

  procedimiento: PROCEDIMIENTO variable PA (params)? PC variables instrucciones FPROCEDIMIENTO;

  params: tipos variable
        | tipos variable COMA params
        ;

  //---TIPOS/EXPRESIONES---

  expr: expr_integer
      | expr_bool
      | expr_seq
      | expr_func
      ;

  expr_integer: expr_sacar_elem                                                 #sacarElemInteger
              | PA expr_integer (POR|SUMA|RESTA) expr_integer PC                #parentesisOpInteger
              | expr_integer (POR|SUMA|RESTA) expr_integer                      #opInteger
              | expr_func                                                       #exprFuncInt
              | NUM                                                             #num
              | variable                                                        #varInt
              ;

  expr_bool: T                                                    #true
           | F                                                    #false
           | expr_sacar_elem                                      #sacarElemBool
           | expr_bool (IGUALL|DISTINTO) expr_bool                #compararBool
           | PA expr_bool (AND|OR) expr_bool PC                   #parentesisOpBool
           | expr_bool (AND|OR) expr_bool                         #opBool
           | expr_seq (IGUALL|DISTINTO) expr_seq                  #compararSeq
           | expr_integer (MENORIGUAL|MAYORIGUAL|MENOR|MAYOR|IGUALL|DISTINTO) expr_integer #compararInteger
           | NO expr_bool                                         #negacionBool
           | expr_func                                            #exprFuncBool
           | variable                                             #varBool
           ;

  expr_seq: CA CC                             #vaciaSeq // []
          | CA (expr COMA)* expr CC           #seq
          | expr_func                         #exprFuncSeq
          | variable                          #varSeq
          ;

  expr_sacar_elem: variable CA expr_integer CC ;

  expr_avanza: LA AVANZA DOSPTOS expr_func LC;

  expr_func: variable PA (expr) (COMA expr)* PC;

  //---INSTRUCCIONES---

  declaracion_instrucciones: asignacion   #asig
                           | condicion    #cond
                           | iteracion    #it
                           | BREAK PyC    #break
                           | devolucion   #dev
                           | mostrar      #show
                           | asertos      #aserto
                           | expr_func PyC #exprfun
                           ;

  devolucion: RETURN (expr COMA)* expr PyC;

  asignacion: (variable COMA)* variable IGUAL (expr COMA)* (expr) PyC;

  condicion: IF PA expr_bool PC THEN (declaracion_instrucciones)+ (blq_sino)? ENDIF;

  blq_sino: ELSE (declaracion_instrucciones)+;

  iteracion: WHILE PA expr_bool PC DO (expr_avanza)? (declaracion_instrucciones)+ ENDWHILE;

  mostrar: MOSTRAR PA (expr COMA)* expr PC PyC;

  asertos: LA ( expr_bool | cuantificador ) LC;

  cuantificador: cuantificadorUniversal
               | cuantificadorExistencial
               ;

  cuantificadorUniversal: FORALL cuantificacion;

  cuantificadorExistencial: EXISTS cuantificacion;

  cuantificacion: PA variable DOSPTOS CA expr_integer COMA expr_integer CC COMA expr_bool PC;

  programa : variables instrucciones EOF
  variables: VARIABLES idents PyC
  idents : VAR COMA idents {actualizar almacen_definiciones con una
  definicion por defecto para VAR}
  | VAR {actualizar almacen_definiciones con una
  definicion por defecto para VAR}
  ;

  instrucciones : INSTRUCCIONES (definicion|evaluacion)*

  definicion : VAR DEF expresion PyC
  {actualizar almacen_definiciones de VAR con expresion}

  {
   si (test_ciclicidad(VAR)=CICLO) entonces
        imprimir mensaje indicando que VAR tiene evaluación
        indefinida
   si no
        valor = evaluar(VAR)
        imprimir_mensaje indicando el valor de VAR
   }

  expresion : PA expresion PC
   | MENOS expresion
   | expresion POR expresion
   | expresion MAS expresion
   | expresion MENOS expresion
   | NUMERO
   | VAR

  evaluacion : EVAL VAR PyC

 VARIABLES x, y, z, a, b;
 INSTRUCCIONES
 a DEF -1; almacen_definiciones =[(x,0),(y,0),(z,0),(a,-1),(b,0)]
 b DEF (a+1); almacen_definiciones =[(x,0),(y,0),(z,0),
 (a,-1),(b,(a+1))]
 EVAL b; almacen_definiciones =[(x,0),(y,0),(z,0),
 (a,-1),(b,(a+1))]
 a DEF 2; almacen_definiciones =[(x,0),(y,0),(z,0),(a,2),(b,(a+1))]
 EVAL b; almacen_definiciones =[(x,0),(y,0),(z,0),(a,2),(b,(a+1))]
 b DEF b + 1; almacen_definiciones =[(x,0),(y,0),(z,0),(a,2),(b,b+1)]
 z DEF 2*y; almacen_definiciones =[(x,0),(y,0),(z,2*y),(a,2),(b,b+1)]
 EVAL z; almacen_definiciones =[(x,0),(y,0),(z,2*y),(a,2),(b,b+1)]
 EVAL b; almacen_definiciones =[(x,0),(y,0),(z,2*y),(a,2),(b,b+1)]