DISEÑO COMPILADOR PROGRAMACION P --> Java
-----------------------------

DISEÑO
------
OBJETIVO:
 Compilador de lenguaje P a lenguaje Java
 P es un lenguaje de programación secuencial con asertos.
 La idea es usar asertos para verificar la corrección del programa.
 Si al ejecutar un programa, sus asertos son ciertos entonces el programa se considera correcto.
 El programa sería incorrecto en otro caso. El programa P se estructura en 3 secciones:
 (a) una dedicada a la declaración de variables (sección VARIABLES),
 (b) otra dedicada a la declaración de subprogramas (sección SUBPROGRAMAS) y
 (c) otra dedicada al uso de variables y subprogramas (sección INSTRUCCIONES).

 Las instrucciones se ejecutan una a una desde el comienzo del
 programa hasta el final del mismo.

 P no admite la asignación de expresiones sin valor a una variable
 La declaración de variables asocia valor 0 por defecto a
 éstas.

 Ejecutar una instrucción significa vincular una expresión
 a una variable para una eventual evaluación.

 Toda definición de una variable solapará sus definiciones
 anteriores en el programa.
 Toda variable definida sobre sí misma se le asocia un valor
 indefinido.
 Ejecutar una instrucción x significa evaluar el valor de
 la expresión asociada a x mostrando por pantalla el
 resultado.

(1) Definir la esquema de traducción de un programa P

    import java.io.*;
    public class _Programa
    {
       public static void main(String[] args) {

          generar codigo para declaracion de variables
          generar codigo para declaracion de subprogramas
          generar codigo para cada instrucción
       }
    }

   (b) generar codigo para declaracion de variables y
       almacenar definiciones por defecto para cada variable.
       (necesario para generar código de subprogramas)
        VARIABLES
            i,max,min:NUM;
            s:SEQ(NUM);
       alamacen_variables=[(i,0),(max,0),(min,0),(s,[i+1]))]
   (c) generar codigo para declaracion de subprogramas que en P
       pueden ser funciones o procedimientos.
   (d) generar codigo para cada instrucción

      (d.1) No se genera código para la definición de subprogramas
           (aunque sea necesario para generar código de instrucciones)

      (d.2) generar codigo para evaluación de variables

            (a) Las variables con definición cíclica hay que
                detectarlas y simular en Java su evaluación en P.

            (b) Las variables con definición no cíclica hay que
                simular en Java su evaluación en P. La definición no cíclica obliga
                a secuenciar las variables de las que depende las variables evaluadas.

                si (test(VAR)=CICLO) entonces
   	               generar codigo para evaluación de
   	               variable indefinida
   	            si no
   	               generar codigo para evaluación de
   	               variable definida
   	        (c)


//DECISIÓN 3:
 Teniendo en cuenta las decisiones anteriores, el programa Java resultante
 de la compilación será la composición secuencial del código
 correspondiente a cada secuencia.
 El estado inicial sólo se genera una vez y se comparte por todas
 las secuencias.


   	Gramática atribuida resultante:
   	------------------------------
    almacen_variables (global)

    programa :  {generar codigo declaracion clase
                 generar codigo cabecera main}
                #(PROGRAMA variables subprogramas instrucciones)
                {generar codigo fin main
                 generar codigo fin clase}

    variables : #(VARIABLES (declaracion_variables)*)

    declaracion_variables: identificador PyC;

    identificador: elementales
                 | secuencias
                 ;

    elementales: (VAR {actualizar estado con una definicion por defecto para VAR})*)
                             {generar codigo declaracion variables}
                  COMA)* VAR DOSPTOS tipos_elementales;

    secuencias: VAR {actualizar estado con una definicion por defecto para VAR})*)
                           {generar codigo declaracion variables}
                DOSPTOS tipos_no_elementales;

    tipos: tipos_elementales
         | tipos_no_elementales
         ;

    tipos_elementales: NUMERO
                     | BOOL
                     ;

    tipos_no_elementales: SEQ_NUM
                        | SEQ_BOOL
                        ;

//---SUBPROGRAMAS---
variable: VAR {actualizar estado con una definicion por defecto para VAR})*)
                                           {generar codigo declaracion variables};

declaracion_subprogramas: funcion
                        | procedimiento
                        ;

funcion: FUNCION variable PA (params)? PC RETURN PA params PC variables instrucciones FFUNCION;

procedimiento: PROCEDIMIENTO variable PA (params)? PC variables instrucciones FPROCEDIMIENTO;

params: tipos variable
      | tipos variable COMA params
      ;

//---TIPOS/EXPRESIONES---

expr: expr_integer
    | expr_bool
    | expr_seq
    | expr_func
    ; {generar codigo para el tipo de expresiones};

expr_integer: expr_sacar_elem                                                 #sacarElemInteger
            | PA expr_integer (POR|SUMA|RESTA) expr_integer PC                #parentesisOpInteger
            | expr_integer (POR|SUMA|RESTA) expr_integer                      #opInteger
            | expr_func                                                       #exprFuncInt
            | NUM                                                             #num
            | variable                                                        #varInt
            ;

expr_bool: T                                                    #true
         | F                                                    #false
         | expr_sacar_elem                                      #sacarElemBool
         | expr_bool (IGUALL|DISTINTO) expr_bool                #compararBool
         | PA expr_bool (AND|OR) expr_bool PC                   #parentesisOpBool
         | expr_bool (AND|OR) expr_bool                         #opBool
         | expr_seq (IGUALL|DISTINTO) expr_seq                  #compararSeq
         | expr_integer (MENORIGUAL|MAYORIGUAL|MENOR|MAYOR|IGUALL|DISTINTO) expr_integer #compararInteger
         | NO expr_bool                                         #negacionBool
         | expr_func                                            #exprFuncBool
         | variable                                             #varBool
         ;

expr_seq: CA CC                             #vaciaSeq // []
        | CA (expr COMA)* expr CC           #seq
        | expr_func                         #exprFuncSeq
        | variable                          #varSeq
        ;

expr_sacar_elem: variable CA expr_integer CC ;

expr_avanza: LA AVANZA DOSPTOS expr_func LC;

expr_func: variable PA (expr) (COMA expr)* PC;

    instrucciones : #(INSTRUCCIONES (declaracion_instrucciones)*)

  //---INSTRUCCIONES---

  declaracion_instrucciones: asignacion   #asig
                           | condicion    #cond
                           | iteracion    #it
                           | BREAK PyC    #break
                           | devolucion   #dev
                           | mostrar      #show
                           | asertos      #aserto
                           | expr_func PyC #exprfun
                           ; {generar codigo para el tipo de declaracion de instrucciones};

  devolucion: RETURN (expr COMA)* expr PyC;

  asignacion: (variable COMA)* variable IGUAL (expr COMA)* (expr) PyC;

  condicion: IF PA expr_bool PC THEN (declaracion_instrucciones)+ (blq_sino)? ENDIF;

  blq_sino: ELSE (declaracion_instrucciones)+;

  iteracion: WHILE PA expr_bool PC DO (expr_avanza)? (declaracion_instrucciones)+ ENDWHILE;

  mostrar: MOSTRAR PA (expr COMA)* expr PC PyC;

  asertos: LA ( expr_bool | cuantificador ) LC;

  cuantificador: cuantificadorUniversal
               | cuantificadorExistencial
               ;

  cuantificadorUniversal: FORALL cuantificacion;

  cuantificadorExistencial: EXISTS cuantificacion;

  cuantificacion: PA variable DOSPTOS CA expr_integer COMA expr_integer CC COMA expr_bool PC;
----------------------------------------------------

generar codigo declaracion clase:
   escribir en fichero:
         import java.io.*;
         public class _Programa{

generar codigo cabecera main:
   escribir en fichero:   public static void main(String[] args) {

generar codigo fin main:
   escribir en fichero:   }

generar codigo fin clase:
   escribir en fichero: }

generar codigo para evaluación de variable VAR indefinida:
   escribir en fichero:
         System.out.println("(Compilador) "+VAR+" ---> INDEF");

generar codigo para evaluación de variable VAR definida:
      dep = calcular las variables de las que depende VAR
            por niveles
      para cada nivel n en dep (de menor a mayor)
        para cada variable v en el nivel n
           def = consultar definicion de v en estado
           cod = generar codigo para expresión def
           escribir en fichero:
             System.out.println("(Compilador) "+v+"="+cod+";");


generar codigo para expresión:
     si la expresion es un NUMERO entonces el código generado es el propio numero
     si la expresion es una VAR entonces el código generado es la propia VAR
     si la expresion es una suma entonces el código generado es la composición del
        código generado para la subexpresión izquierda, el código + y
        código generado para la subexpresión derecha
    si la expresion es una resta,producto o división entonces el código generado es
       similar al código de la suma salvo el operador aritmético.
