OBJETIVO 1 (abstracto y declarativo): analizador semántico capaz de decidir si la seccion
instrucciones del programa en un lenguaje llamado P están bien estructuradas (suponemos que los
programas P siempre usan variables y subprogramas).

OBJETIVO 2 (concreto y declarativo):analizador semántico capaz de decidir si la seccion
instrucciones del programa  en un lenguaje llamado P están bien estructuradas (suponemos que los
programas P siempre usan variables y subprogramas).
(a) Las instrucciones del programa llamado P esta bien estructuras si y sólo si están formadas por
    asignaciones, condiciones, iteraciones, rupturas de control, llamada a subprogramas, devuelven el resultdo,
    muestran por consola el valor y asertos.
(b) Una instruccion es una asignacion bien estructurada si y solo si está formada por una expresión entera,
    expresion booleana o expresión secuencial
    (b.1) Una expresión es de tipo entera si y sólo si es una constante entera, una variable entera
          o la suma, resta o producto de expresiones enteras.
    (b.2) Una expresión es de tipo booleana si y sólo si es una constante booleana, o una variable
          booleana
    (b.3) Una expresión es de tipo secuencial si y sólo si es una constante secuencia, una variable
          booleana o una variable entera
    (b.4) Una asignacion no admite expresiones sin valor a una variable
(c) Una instruccion es una condicion bien estructurada si y solo si están formadas por expresiones de tipo boolean
    y un bloque de instrucciones
    (c.1) Las condiciones se contruyen en base a igualdades y desigualdades de expresiones con el mismo tipo
    (c.2) Las condiciones se pueden concatenar con operadores de conjuncion, disyuncion y negacion
    (c.3) Las condiciones se evaluan a variable boolean e indefinido
(d) Una instruccion es una iteracion bien estructurada si y solo si esta formada por un bloque de instrucciones
    con una condicion al principio
    (d.1) A una iteracion se le puede asociar una funcion avance incluida en las expresiones funcion
    (d.2) Una iteracion es erronea si los valored devueltos por funcion de avance no decrecen
(e) Una instruccion ruputura de control esta bien estructura si y solo si lleva al programa
    fuera del bloque y pospone comprobacion
(f) Una instruccion que hace declaracion de subprograma esta bien estructura si y solo si
    permite hacer llamadas a los mismos
    (f.1) Llamada a una funcion es parte de un una expresion.
    (f.2) Un procedimiento nunca es parte de una expresion.
(g) Una instruccion mostrar esta bien estructura si y solo si muestra por consola lista de variables.
(h) Una instruccion aserto esta bien estructurado si y solo si es una expresion booleana y cuantificador
    (h.1) cuantificación universal, ej. PARATODO(p:[0,ultima_posicion(s)],s[i]<=max)
    (h.2) cuantificación existencial ej. EXISTE(x:[0,ultima_posicion(s)],s[x]>10)

    ===========================================================================

   GRAMATICA ATRIBUIDA

   ==============================================
   ARGUMENTO DISEÑO 1: OBJETIVO 2 => OBJETIVO 1
   ==============================================

   DECISIÓN DISEÑO 1: Para decidir si una instruccion es correcta, se
   necesita saber el tipo de las variables implicadas.
   Se necesita almacenar esta información al procesar la declaración de
   variables.
   (almacén variables) variable | tipo
                       ---------------------------------
                       i,max,min | NUM, variables numericas
                       SEQ(NUM)  | secuencia de enteros
                       SEQ(LOG)  | secuencia logica
                       T,F       | LOG, variables logicas

   programa : PROGRAMA n=variables {almacenar n en alamacen} subprogramas instrucciones

   (parámetro de salida n)
   variables : VARIABLES (m=decl_vars {almacenar m en n})*
   (parámetro de salida m)
   decl_vars : r=vars DOSPTOS t=tipo PyC {almacenar en m cada variable en r con tipo t}
   (parámetro de salida t)
   tipo: NUMERO {t=variables numericas}
    | BOOL {t=variables logicas}
    | SEQ(NUM) {t=secuencia numerica}
    | SEQ(LOG) {t=secuencia logica}
    ;
   (parámetro de salida r)
   vars : (variable {incluir variable en r} COMA)* variable

   -----------------------------------------------------------
   ARGUMENTO DISEÑO 2: DECISIÓN DISEÑO 2=> OBJETIVO 2 (a)
   ---------------------------------------------------------
   DECISIÓN DISEÑO 3:El cálculo del tipo de una expresión se basa en las
   siguientes funciones:

     ==========================================================
           PSEUDOCODIGO EXPR_INTEGER

           (función tipo_op_aritm(tipo1,tipo2
               si tipo1 o tipo2 es igual a no tipo entonces
                   tipo= no tipo
               sino
                   si tipo1 y tipo2 son enteros entonces
                       tipo=entero
                   sino tipo=no tipo)

     ==========================================================
       PSEUDOCODIGO EXPR_BOOLEAN

       (función tipo_op_booleano(tipo1,tipo2)
           si tipo1 o tipo2 es igual a no tipo entonces
               tipo= no tipo
           sino
               si tipo1 y tipo2 son booleanos entonces
                   tipo=booleano
               sino tipo=no tipo)

    ==========================================================

     PSEUDOCODIGO EXPR_SEQ

           (función tipo_seq_elems(tipos)
               si algun elemento en tipos es igual a no tipo
                    o es igual a corchetes vacios entonces
                   tipo= no tipo
               sino
                  si todos los elementos en tipos son iguales a  entero entonces
                       tipo=entero
                  sino
                    si todos los elementos en tipos son iguales a  booleano entonces
                        tipo=booleano)

     ==========================================================
            PSEUDOCODIGO FUNCION TIPO AVANCE

            (función tipo_avance(tipo1,tipo2)
                si tipo1 o tipo2 es igual a no tipo entonces
                    tipo= no tipo
                sino
                    si tipo1 y tipo2 son booleanos entonces
                        tipo=booleano
                    sino tipo=no tipo)

     ==========================================================
      PSEUDOCODIGO FUNCION TIPO ULTIMA POSICION

                 (función tipo_ultima_posicion(tipo1,tipo2)
                     si tipo1 o tipo2 es igual a no tipo entonces
                         tipo= no tipo
                     sino
                         si tipo1 y tipo2 son booleanos entonces
                             tipo=booleano
                         sino tipo=no tipo)

     ==========================================================

    -------------------------------------------------------------
    ARGUMENTO DISEÑO 2: DECISIÓN DISEÑO 2=> OBJETIVO 2 (b). .(h)
    -----------------------------------------------------------
    DECISIÓN DISEÑO 2: Para decidir si los argumentos desde (b)..(h) cumplen con el objetivo.
   
    (parámetro de salida tipo)
    expr: tipo=expr_booleana
          | tipo=expr_entera
          | tipo=expr_secuencia

    (parámetro de salida tipo)
    variable: VAR {tipo=tipo almacenado para VAR en almacén variables}

    funcion_booleana_binaria = AND|OR

    desigualdades: DISTINTO
             | MENOR
             | MAYOR
             | MENOR_IGUAL
             | MAYOR_IGUAL
             ;
    (parámetro de salida tipo)
    expr_boolean: T
            | F
            | expr_integer desigualdades expr_integer
            | tipo1=expr_boolean funcion_booleana_binaria tipo2=expr_boolean
            | NO tipo1=expr_boolean
            | expr_integer
            ;

    operacion_entero: MULTIPLICACION
                | SUMA
                | RESTA
                ;
    (parámetro de salida tipo)
    expr_integer: NUM {tipo=entero}
            | tipo1=expr_integer operacion_entero tipo2=expr_integer
            | tipo=identificador CA expr_integer CC // variable que almacena una secuencia de enteros
            | expr_funcion // llamar a esa función devuelva un entero
            | variable
            ;
    (parámetro de salida tipos)
    expre_seq: CA CC
             | CA ((tipo=expr_entera | tipo=expr_booleana | tipo=variable) COMA )*
                  (tipo=expr_entera | tipo=expr_booleana | tipo=variable) CC {añadir tipo a tipos}
             | expr_funcion
             ;














