OBJETIVO:

 -Propuestos:
  ERROR 1:
        PROGRAMA
        VARIABLES
            seq:SEQ(NUM);
            i:NUM;
        SUBPROGRAMAS
        INSTRUCCIONES
            seq = 1; // Error 1 por asignación mal tipada. seq es una SEQ(NUM) mientras que 1 es una cte tipo NUM.
            i = T; // Error 1 por asignación mal tipada. i es una variable tipo NUM mientras que T es una cte tipo LOG.

   El analizador semántico, por tanto, debe ser capaz de detectar si las asignaciones en P están bien tipadas.
   Una asignación está bien tipada si y solo sí el tipo de la expresión a asignar coincide con el tipo de la variable
   que se está asignando:

    a)	Una expresión es de tipo entero si y sólo si es una constante o variable entera; una operación matemática suma,
    resta o producto entre dos expresiones enteras; una función que devuelva un número entero; o la extracción de un
    valor de una secuencia numérica.
    b)	Una expresión es de tipo booleano si y sólo si es una constante o variable booleana; la conjunción, disyunción o
    negación de expresiones booleanas; la comparación entre expresiones booleanas; la comparación entre expresiones
    enteras; una función que devuelva un booleano; o la extracción de un valor de una secuencia booleana. Consideramos
    que una condición puede devolver un resultado ambiguo en caso de que uno de los operandos sea ambiguo (ej: variable sin valor).
    c)	Una expresión es de tipo secuencia entera si y sólo si es un conjunto de expresiones enteras o una variable de tipo secuencia
    entera. Puede estar vacía.
    d)	Una expresión es de tipo secuencia booleana si y sólo si es un conjunto de expresiones booleanas o una variable de tipo
    secuencia booleana. Puede estar vacía.

  ERROR 2:
        PROGRAMA
        VARIABLES
            loEs:LOG;
            i:NUM;
        SUBPROGRAMAS
            FUNCION esTrue(LOG v) dev (LOG loEs)
                ...
            FFUNCION
        INSTRUCCIONES
            i = 2*3;
            loEs = esTrue(i); // Error 2 por introducción de parámetro cuyo tipo no coincide con el declarado como entrada en la función.

  El analizador semántico debe ser capaz de detectar si las expresiones pasadas como parámetros de un subprograma corresponden con
  los tipos de los parámetros de entrada de dicha función.

 ERROR 3:
   PROGRAMA
   VARIABLES
      ...
   SUBPROGRAMAS
       FUNCION esTrue(LOG v) dev (LOG loEs)
        VARIABLES
           i:NUM;
        INSTRUCCIONES
           i = 1;
           dev i; //Error 3. Se está devolviendo la variable i en lugar de loEs.
       FFUNCION
   INSTRUCCIONES
       ...

    El analizador semántico deberá ser capaz de detectar que el tipo de la expresión/variable devuelta coincide con el tipo de devolución
    indicado en la cabecera de la función.

 ERROR 4:
     PROGRAMA
     VARIABLES
        i:NUM;
        j:NUM;
     SUBPROGRAMAS
        ...
     INSTRUCCIONES
        j = i+2; //Error 4. i es indefinido.

  El analizador semántico debe ser capaz de detectar variables indefinidas.
  Se considera variable indefinida aquella a la que no se le ha asignado ninguna expresión, o en su defecto, se le ha asignado una
  expresión indefinida.
  Se considera una expresión indefinida a aquella que contiene una variable sin valor asignado.

 ERROR 5:
     PROGRAMA
     VARIABLES
        i:NUM;
     SUBPROGRAMAS
        ...
     INSTRUCCIONES
        j = 7; //Error 5. Se está asignando a una variable no declarada un valor.
        prueba(k); //Error 5. Se está pasando como parámetro una variable no declarada. ¿Definir como errores distintos?
                                                                           Hay que tener en cuenta tmb usos en otro tipo d expresiones.

   El analizador semántico debe ser capaz de detectar usos de variables no declaradas.

 ERROR 6:
     PROGRAMA
     VARIABLES
        i:NUM;
        i:NUM; //Error 6. Se está declarando una misma variable varias veces.
     SUBPROGRAMAS
         FUNCION esTrue(LOG v) dev (LOG loEs)
          VARIABLES
             i:LOG; //Error 6.
          INSTRUCCIONES
             ...
         FFUNCION
     INSTRUCCIONES
        ...

   El analizador semántico debe ser capaz de detectar las declaraciones múltiples.

//posible ERROR 7 -> BREAK fuera de bucle.
//mirar asertos

 DECISIONES DE DISEÑO error 1 (error asignación):
 
     (DECISIÓN 1.1)
        Para saber si una asignación está bien tipada necesitamos un almacén que contenga información acerca del tipo de las variables declaradas.
        De este modo, cuando se produzca una asignación podremos comprobar si el valor asignado a dicha variable concuerda con el tipo registrado
        en el almacén.
 
        Almacén de variables globales (programa): (en el caso de comprobar asignaciones de subprogramas tendremos que mirar el almacén correspon-
                                                    diente en el almacén de subprogramas -> Ver decisión 2.1)
            variables   |    tipos
         --------------------------------------
             seq        |    Secuencia numérica
             i          |    Numérico
             loEs       |    Lógico
 
 
        programa: PROGRAMA n=variables {almacenar n en almacén} subprogramas instrucciones EOF;
 
        (parámetro de salida n)
        variables: VARIABLES (m=declaracion_variables {almacenar m en n})*;
 
        (parámetro de salida m)
        declaracion_variables: (r,t)=identificador PyC; {Almacenar en m cada variable en r con tipo t}
 
        (parámetro de salida (r,t))
        identificador: elementales
                     | secuencias
                     ;
 
        (parámetro de salida (r,t))
        elementales: (VAR {incluir VAR en r} COMA)* VAR {incluir VAR en r} DOSPTOS t=tipos_elementales {incluir r y t en (r,t)};
 
        (parámetro de salida (r,t))
        secuencias: VAR {incluir VAR en r} DOSPTOS t=tipos_no_elementales {incluir r_y_t en (r,t)};
 
        (parámetro de salida t)
        tipos: tipos_elementales
             | tipos_no_elementales
             ;
 
        tipos_elementales: NUMERO {t=numero}
                         | BOOL {t=lógico}
                         ;
 
        tipos_no_elementales: SEQ_NUM {t=secuencia numérica}
                            | SEQ_BOOL {t=secuencia lógica}
                            ;
     (DECISIÓN 1.2)
     Una asignación está bien tipada sí y solo sí el tipo de la variable coincide con el tipo de la expresión asignada.
 
     funcion comprobarTiposAsignación(tipo_var, tipo_expr)
         si tipo expr es igual a tipo invalido
             error
         sino
             si tipo_var es igual a tipo_expr entonces
                 no error
             sino
                 error
 
     funcion comprobaciónTiposAsignaciones(tipo_vars, tipo_exprs) //para asignaciones múltiples.
         almacen n
         pares = pares_var_expr(tipo_vars, tipo_exprs)
         para cada par en pares:
             añado en n comprobarTiposAsignación(tipo_var en par, tipo_expr en par)
         si en n no error entonces
             no error
         sino
             error
 
     (DECISIÓN 1.3)
     El cálculo del tipo de una expresión se basa en las siguientes funciones.
 
     funcion tipoOperaciónNumérica(tipo1,tipo2)
           si tipo1 o tipo2 es igual a tipo inválido entonces
                 tipo = tipo inválido
           sino
                 si tipo1 es igual a tipo2 entonces //no hay que mirar si tipo1 o tipo2 son numéricos pues ya lo comprueba el sintáctico
                     tipo = tipo1
                 sino
                     tipo = tipo inválido
 
     funcion tipoComparaciónNumérica(tipo1,tipo2)
          si tipo1 o tipo2 es igual a tipo inválido entonces
                tipo = tipo inválido
          sino
                 si tipo1 y tipo2 son iguales entonces //no hay que mirar si tipo1 o tipo2 son numéricos pues ya lo comprueba el sintáctico
                     tipo = lógico
                 sino
                     tipo = tipo inválido
 
     funcion tipoComparaciónIgualdad(tipo1,tipo2)
          si tipo1 o tipo2 es igual a tipo inválido entonces
                tipo = tipo inválido
          sino
                 tipo = lógico
 
      funcion tipoOperaciónLógica(tipo1,tipo2)
            si tipo1 o tipo2 es igual a tipo inválido entonces
                  tipo = tipo inválido
            sino
                  si tipo1 y tipo2 son iguales entonces
                      tipo = tipo1
                  sino
                      tipo = tipo inválido
 
      funcion tipoSeqElementos(tipos)
            si algún elemento en tipos es tipo inválido o secuencia entonces
                 tipo = tipo inválido
            sino
                 si todos los elementos son numéricos entonces
                     tipo = secuencia numérica
                 en otro caso si todos los elementos son lógicos entonces
                     tipo = secuencia lógica
                 sino
                     tipo = tipo inválido
 
     (DECISIÓN 1.4)
     El cálculo del tipo de una expresión se basa en las siguientes funciones.
 
     funcion tipoOperaciónNumérica(tipo1,tipo2)
           si tipo1 o tipo2 es igual a tipo inválido entonces
                 tipo = tipo inválido
           sino
                 si tipo1 y tipo2 son numéricos entonces
                     tipo = tipo1
                 sino
                     tipo = tipo inválido
 
     funcion tipoComparaciónNumérica(tipo1,tipo2)
          si tipo1 o tipo2 es igual a tipo inválido entonces
                tipo = tipo inválido
          sino
                 si tipo1 y tipo2 son iguales a numérico entonces
                     tipo = lógico
                 sino
                     tipo = tipo inválido
 
     funcion tipoComparaciónIgualdad(tipo1,tipo2)
          si tipo1 o tipo2 es igual a tipo inválido entonces
                tipo = tipo inválido
          sino
                 tipo = lógico
 
      funcion tipoOperaciónLógica(tipo1,tipo2)
            si tipo1 o tipo2 es igual a tipo inválido entonces
                  tipo = tipo inválido
            sino
                  si tipo1 y tipo2 son iguales a booleano entonces
                      tipo = tipo1
                  sino
                      tipo = tipo inválido
 
      funcion tipoSeqElementos(tipos)
            si algún elemento en tipos es tipo inválido o secuencia entonces
                 tipo = tipo inválido
            sino
                 si todos los elementos son numéricos entonces
                     tipo = secuencia numérica
                 en otro caso si todos los elementos son lógicos entonces
                     tipo = secuencia lógica
                 sino
                     tipo = tipo inválido
 
      funcion tipoElementoDeSecuencia(expr_sacar_elem)
           identificador = sacar de expr_sacar_elem nombre identificador
           tipo = tipoVariable(identificador)
 
 
     funcion tipoVariable(identificador)
         si identificador en almacen(=n) global:
             tipo = n[identificador]
         en otro caso si estamos en función:
             almacenFuncion = extraer de almacen de funciones (=k) el almacen de la funcion(=[PARAM(...), DEV(...), CUERPO(...)]
             tipo = tipo inválido //si no se haya en ningun lugar declarada la variable entonces no tiene tipo
             para cada subAlmacen en almacenFuncion:
                 si identificador en subAlmacen:
                     tipo = subAlmacen[identificador]
                     fin
         sino:
             tipo = tipo inválido


     funcion tipoFuncion(expr_func)
         almacenFuncion = extraer de k el almacen de la funcion
         tipo = almacenFuncion[DEV] //tipo sería una colección de los tipos devueltos por la función.
 
 DECISIONES DE DISEÑO error 2 (error asignación a parámetros de subprograma expresiones con tipo no válido):
 
     (DECISIÓN 2.1)
         Para saber si las asignaciones sobre los parámetros de subprogramas son adecuadas necesitamos de un almacén
         que contenga tantas entradas como subprogramas tenga nuestro programa.
         Por cada una de estas entradas nos encontraremos con un almacén que contiene las variables y tipos de
         dicho subprograma, dividiéndose en tres categorías: PARAM (las que se esperan recibir como parámetros), DEV
         (las que se esperan devolver) y CUERPO (las declaradas en variables).
 
          Almacén k de variables de subprogramas:
          ------------------------------------------------------------
          func1   |      PARAM             DEV             CUERPO
          (f1)    |---------------------------------------------------
                  |variables tipos | variables tipos | variables tipos
                  |
                  |
          ------------------------------------------------------------
          func2   |      PARAM             DEV             CUERPO
          (f2)    |---------------------------------------------------
                  |variables tipos | variables tipos | variables tipos
                  |
                  |
           .
           .
          (fn) n=num de funciones
 
          programa: PROGRAMA variables k=subprogramas instrucciones EOF;
 
          (parámetro de salida k)
          subprogramas: SUBPROGRAMAS (f=declaracion_subprogramas {almacena f en k})*;
 
          (parámetro de salida f)
          declaracion_subprogramas: funcion
                                  | procedimiento
                                  ;
 
          (parámetro de salida f)
          funcion: FUNCION variable PA (PARAM=params)? PC RETURN PA DEV=params PC CUERPO=variables instrucciones FFUNCION;
         {Almacena en f PARAM, DEV y CUERPO}
 
         (parámetro de salida f)
          procedimiento: PROCEDIMIENTO variable PA (PARAM=params)? PC CUERPO=variables instrucciones FPROCEDIMIENTO;
         {Almacena en f PARAM, DEV (vacío) y CUERPO}
 
         (parámetro de salida PARAM o DEV)
          params: t=tipos r=variable {Almacena en PARAM o DEV t y r}
                | t=tipos r=variable COMA params {Almacena en PARAM o DEV t y r} //recursividad revisar
                ; (obtención de m vista en la decisión de diseño del error 1)
 
          (parámetro de salida CUERPO)
          variables: VARIABLES (m=declaracion_variables)*; {Almacena en CUERPO m}
          ... (obtención de m vista en la decisión de diseño del error 1)
 
     (DECISIÓN 2.2)
     Una asignación de una expresión sobre un parámetro a función está bien tipada sí y solo sí el tipo de dicha
     expresión coincide con el tipo del parámetro.

      función comprobarAsignacionesAParámetros(tipo_parametros, tipo_exprs)
             almacen n
             pares = pares_var_expr(tipo_parametros, tipo_exprs)
             para cada par en pares:
                 añado en n comprobarAsignaciónAParámetro(tipo_param en par, tipo_expr en par)
             si en n no error entonces
                 no error
             sino
                 error
 
     función comprobarAsignaciónAParámetro(tipo_parametro, tipo_expr)
            si tipo_parametro es igual a tipo_expr entonces
                no error
            sino
                error

 DECISIONES DE DISEÑO error 3 (error por devolución de tipos distintos a indicados en cabecera de subprograma):
 
     (DECISIÓN 3.1)
     Una devolución es errónea si el tipo de los elementos devueltos no coincide con los tipos de los elementos a
     devolver por orden o bien porque el número de elementos devueltos no coincide con el número de los indicados
     en la cabecera.
 
     función comprobarDevolucion(tipo_devuelto, tipo_aDevolver)
            si tipo_devuelto es igual a tipo_aDevolver entonces
                no error
            sino
                error

     función comprobarAsignacionesAParámetros(tipos_devueltos, tipos_aDevolver)
            almacen n
            pares = pares_var_expr(tipos_devueltos, tipos_aDevolver)
            para cada par en pares:
                añado en n comprobarDevolucion(tipo_devuelto en par, tipo_aDevolver en par)
            si en n no error entonces
                no error
            sino
                error

 DECISIONES DE DISEÑO error 4 (error por uso de variables ambiguas):

    (DECISIÓN 4.1)
    Una variable ambigua es aquella a la que aún no se le ha asociado ningún valor o en su defecto, aquella a la que
    se le ha asociado una expresión formada al menos por una variable ambigua.

    Almacén de ambiguedad: { i:True, j:False ... }. True en caso de ambigua, False en caso contrario.
    Almacén de ambiguedad de subprogramas: { Subprograma1: { i:True, j:False ... } , ... }

    programa: PROGRAMA v=variables {almacenar v en almacén} sv=subprogramas {almacenar sv en almacén de subprogramas} instrucciones EOF;

    (parámetro de salida sv)
     subprogramas: SUBPROGRAMAS (r=declaracion_subprogramas {almacena rs en sv})*;

    (parámetro de salida sr)
     declaracion_subprogramas: funcion
                             | procedimiento
                             ;

    (parámetro de salida nf)
     funcion: FUNCION nf=variable PA (PARAM=params)? PC RETURN PA DEV=params PC CUERPO=variables instrucciones FFUNCION;
                nf: {Almacena en sr los elementos de PARAM, DEV y CUERPO}

    (parámetro de salida nf)
     procedimiento: PROCEDIMIENTO nf=variable PA (PARAM=params)? PC CUERPO=variables instrucciones FPROCEDIMIENTO;
                nf: {Almacena en sr los elementos de PARAM, DEV (vacío) y CUERPO}

    (parámetro de salida PARAM o DEV)
     params: tipos r=variable {Almacena en PARAM o DEV (r,True)}
           | tipos r=variable {Almacena en PARAM o DEV (r,True)} COMA s=params
           ;

    (parámetro de salida n o CUERPO)
    variables: VARIABLES (m=declaracion_variables {almacenar (r,True) en n o CUERPO})*;

    (parámetro de salida r)
    declaracion_variables: r=identificador PyC;

    (parámetro de salida r)
    identificador: elementales
                 | secuencias
                 ;

    (parámetro de salida r)
    elementales: (VAR {incluir VAR en r} COMA)* VAR {incluir VAR en r} DOSPTOS tipos_elementales;

    (parámetro de salida r)
    secuencias: VAR {incluir VAR en r} DOSPTOS tipos_no_elementales;

 En el momento en el que se produzca una asignación sobre una variable deberemos cambiar su valor asociado en el almacén de
 ambigüedad por False. A no ser que lo que se asigne sea una expresión que contenga una variable ambigua, en cuyo caso se
 seguirá siendo ambigua.

 DECISIONES DE DISEÑO error 5 (error por uso de variable no declarada):

     (DECISIÓN 5.1)
     P no permite el uso de variables que no están declaradas. //resoluble en funcion tipoVariable de manera más eficiente.

     función compruebaDeclaración(identificador)
        si identificador en almacen de programa //significaría que es una variable global
            no error
        si estamos en un subprograma
            f = almacén de variables del subprograma
            si identificador está en alguno de los almacenes de f(=PARAM, DEV, CUERPO) //variable local
                no error
            sino  //si no es ni local ni global no ha sido declarada
                error
        sino
            error //si no estamos en subprograma y se hace uso de una variable que no es global, error.

     Por cada aparición de una variable deberemos hacer uso de esta función para asegurarnos que haya sido declarada.

 DECISIONES DE DISEÑO error 6 (error por declaración múltiple de una misma variable):

    (DECISIÓN 6.1)
    P no permitirá la declaración de una misma variable múltiples veces.

    función compruebaYaDeclarados(identificadores) // i,max,j:NUM; -> identificadores = {i,max,j}
        para cada ident en identificadores
            si compruebaDeclaracion(ident) no error //compruebaDeclaración devuelve error si no existe en almacén
                error
            sino
                no error

 GRAMÁTRICA ATRIBUIDA:

        almacénG -> almacén de tipos de variables globales
        almacénF -> almacén de tipos de variables de subprogramas
        aAmbigüedad -> almacén con información de ambiguedad de las variables

        programa: PROGRAMA n=variables {almacenar n en almacén} k=subprogramas {almacenar k en almacénF} instrucciones EOF;

        (parámetro de salida k)
         subprogramas: SUBPROGRAMAS (f=declaracion_subprogramas {almacena f en k})*;

         (parámetro de salida f)
         declaracion_subprogramas: funcion
                                 | procedimiento
                                 ;

        (parámetro de salida f)
         funcion: FUNCION variable PA (PARAM=params)? PC RETURN PA DEV=params PC CUERPO=variables instrucciones FFUNCION;
        {Almacena en f PARAM, DEV y CUERPO}

        (parámetro de salida f)
         procedimiento: PROCEDIMIENTO variable PA (PARAM=params)? PC CUERPO=variables instrucciones FPROCEDIMIENTO;
        {Almacena en f PARAM, DEV (vacío) y CUERPO}

        (parámetro de salida PARAM o DEV)
         params: t=tipos r=variable {Almacena en PARAM o DEV t y r. Almacena en aAmbigüedad r}
                | t=tipos r=variable COMA params {Almacena en PARAM o DEV t y r. Almacena en aAmbigüedad r} //recursividad revisar
                ; (obtención de m vista en la decisión de diseño del error 1)

        (parámetro de salida n,CUERPO)
        variables: VARIABLES (m=declaracion_variables {almacenar m en n o CUERPO})*;

        (parámetro de salida m)
        declaracion_variables: (r,t)=identificador PyC; {Almacenar en m cada variable en r con tipo t}

        (parámetro de salida (r,t))
        identificador: elementales
                     | secuencias
                     ;

        (parámetro de salida (r,t))
        elementales: (VAR {incluir VAR en r} COMA)* VAR {incluir VAR en r} DOSPTOS t=tipos_elementales {incluir r y t en (r,t). Almacena en aAmbigüedad (r,True)};

        (parámetro de salida (r,t))
        secuencias: VAR {incluir VAR en r} DOSPTOS t=tipos_no_elementales {incluir r y t en (r,t). Almacenar en aAmbigüa (r,True)};

        (parámetro de salida t)
        tipos: tipos_elementales
             | tipos_no_elementales
             ;

        tipos_elementales: NUMERO {t=numero}
                         | BOOL {t=lógico}
                         ;

        tipos_no_elementales: SEQ_NUM {t=secuencia numérica}
                            | SEQ_BOOL {t=secuencia lógica}
                            ;