
OBJETIVO 1:

El analizador semántico debe ser capaz de detectar si las asignaciones en P están bien tipadas.

a) Una asignación está bien tipada si y solo sí el tipo de la expresión a asignar
coincide con el tipo de la variable que se está asignando.

b) Una expresión es numérica en los siguientes casos:
    b.1) Constante de tipo numérico.
    b.2) Variable de tipo numérico.
    b.3) Resultado de la suma, resta o multiplicación.
    b.4) Llamada a una función con valor numérico de retorno. (? preguntar)
    b.5) En la extracción del valor iésimo en una secuencia numérica.

c) Una expresión es de tipo lógico en los siguientes casos:
    c.1) Constante de tipo lógico.
    c.2) Variable de tipo lógico.
    c.3) Resultado del AND y OR lógicos entre dos expresiones lógicas.
    c.4) Resultado de comprobar la igualdad o desigualdad entre dos expresiones de igual tipo.
    c.5) Resultado de ejercer las comparaciones menor, mayor, menor igual o mayor igual entre dos expresiones numéricas.
    c.6) Resultado del NO lógico de una expresión lógica.
    c.7) Llamada a una función con un valor lógico de retorno.
    c.8) En la extracción del valor iésimo en una secuencia de valores lógicos.

d) Una expresión es de tipo secuencia numérica o lógica en los siguientes casos:
    d.1) Lista por extensión [...]. En el caso de almacenar valores enteros será una secuencia entera.
        En el caso de almacenar valores lógicos una secuencia lógica.
        En el caso de estar vacía tomará el tipo requerido en la asignación siempre y cuando la variable por asignar
        tenga como tipo la secuencia numérica o lógica.
    d.2) Variable de tipo secuencia numérica o lógica.
    d.3) Llamada a una función que devuelva un valor secuencia numérica o lógica como retorno.

f) Una expresión tiene tipo inválido si no se le puede asignar ninguna de las expresiones anteriores.

/*CONSIDERACIÓN: consideramos 8 tipos distintos de funciones: asignación, condición, iteración,
               ruptura, devolución, mostrar, asertos y llamada a función.
               De estas, nos vemos obligados a definir gramáticas atribuidas debido a las limitaciones del
               sintáctico en las siguientes: asignación y expresión función. En el resto, en el caso de asignaciones
               erróneas, el analizador léxico sintáctico las reconocería.*/

    ERRORES PROPUESTOS:
        PROGRAMA
        VARIABLES
            seq:SEQ(NUM);
            i:NUM;
            loEs:LOG;
        SUBPROGRAMAS
            FUNCION esTrue(LOG v) dev (LOG loEs)
             VARIABLES
             INSTRUCCIONES
                loEs = v;
                dev loEs;
            FFUNCION
            FUNCION prueba(LOG logico) dev (NUM var2)
             VARIABLES
             INSTRUCCIONES
                var2 = 2*3;
                dev var2; //Error 3 por devolución de una variable que no
            FFUNCION
        INSTRUCCIONES
            seq = 1; // Error 1 por asignación mal tipada. seq es una SEQ(NUM) mientras que 1 es una cte tipo NUM.
            i = T; // Error 1 por asignación mal tipada. i es una variable tipo NUM mientras que T es una cte tipo LOG.
            loEs = esTrue(i); // Error 2 por introducción de parámetro cuyo tipo no coincide con el declarado como entrada en la función.
                             // La asignación a la variable loEs sí sería correcta.

DECISIÓN DE DISEÑO SOBRE EL ERROR 1:

DECISIÓN 1.1:
Para saber si una asignación está bien tipada necesitamos un almacén que contenga información acerca del tipo de las variables declaradas.
De este modo, cuando se produzca una asignación podremos comprobar si el valor asignado a dicha variable concuerda con el tipo registrado
en el almacén.

Almacén de variables:

    variables   |    tipos
 --------------------------------------
     seq        |    Secuencia numérica
     i          |    Numérico
     loEs       |    Lógico


programa: PROGRAMA n=variables {almacenar n en almacén} subprogramas instrucciones EOF;

(parámetro de salida n)
variables: VARIABLES (m=declaracion_variables {almacenar m en n})*;

(parámetro de salida m)
declaracion_variables: r=identificador DOSPTOS PyC; {Extraer de r_y_t r y t. Tras esto, almacenar en m cada variable en r con tipo t}

(parámetro de salida r_y_t)
identificador: elementales
             | secuencias
             ;

(parámetro de salida r_y_t)
elementales: (VAR {incluir VAR en r} COMA)* VAR {incluir VAR en r} DOSPTOS t=tipos_elementales {incluir r y t en r_y_t};

(parámetro de salida r_y_t)
secuencias: VAR {incluir VAR en r} DOSPTOS t=tipos_no_elementales {incluir r_y_t en unión};

(parámetro de salida t)
tipos: tipos_elementales
     | tipos_no_elementales
     ;

tipos_elementales: NUMERO {t=numero}
                 | BOOL {t=lógico}
                 ;

tipos_no_elementales: SEQ_NUM {t=secuencia numérica}
                    | SEQ_BOOL {t=secuencia lógica}
                    ;

DECISIÓN 1.2:
Una asignación está bien tipada sí y solo sí el tipo de la variable coincide con el tipo
de la expresión asignada.

funcion comprobarTiposAsignación(tipo_var, tipo_expr)
    si tipo expr es igual a tipo invalido
        error
    sino
        si tipo_var es igual a tipo_expr entonces
            no error
        sino
            error

funcion comprobaciónTiposAsignaciones(tipo_vars, tipo_exprs) //para asignaciones múltiples
    almacen n
    pares = pares_var_expr(tipo_vars, tipo_exprs)
    para cada par en pares:
        añado en n comprobarTiposAsignación(tipo_var en par, tipo_expr en par)
    si en n no error entonces
        no error
    sino
        error

DECISIÓN 1.3:
Una asignación de una expresión sobre un parámetro a función está bien
tipada sí y solo sí el tipo de dicha expresión coincide con el tipo
del parámetro.

función comprobarAsignaciónAParámetro(tipo_parametro, tipo_expr)
       si tipo_parametro es igual a tipo_expr entonces
           no error
       sino
           error

función comprobarAsignacionesAParámetros(tipo_parametros, tipo_exprs)
       almacen n
       pares = pares_var_expr(tipo_parametros, tipo_exprs)
       para cada par en pares:
           añado en n comprobarAsignaciónAParámetro(tipo_param en par, tipo_expr en par)
       si en n no error entonces
           no error
       sino
           error

//hay que comprobar también que el tipo del valor devuelto coincide con el tipo indicado que se devolverá

DECISIÓN 1.4:
El cálculo del tipo de una expresión se basa en las siguientes funciones.

funcion tipoVariable(identificador)
    si identificador en almacen(=n) global:
        tipo = n[identificador]
    en otro caso si estamos en función:
        almacenFuncion = extraer de almacen de funciones (=k) el almacen de la funcion(=[PARAM(...), DEV(...), CUERPO(...)]
        tipo = tipo inválido //si no se haya en ningun lugar declarada la variable entonces no tiene tipo
        para cada subAlmacen en almacenFuncion:
            si identificador en subAlmacen:
                tipo = subAlmacen[identificador]
                fin
    sino:
        tipo = tipo inválido

funcion tipoFuncion(expr_func)
    almacenFuncion = extraer de k el almacen de la funcion
    tipo = almacenFuncion[DEV] //tipo sería una colección de los tipos devueltos por la función.

funcion tipoOperaciónNumérica(tipo1,tipo2)
      si tipo1 o tipo2 es igual a tipo inválido entonces
            tipo = tipo inválido
      sino
            si tipo1 y tipo2 son numéricos entonces
                tipo = tipo1
            sino
                tipo = tipo inválido

funcion tipoComparaciónNumérica(tipo1,tipo2)
     si tipo1 o tipo2 es igual a tipo inválido entonces
           tipo = tipo inválido
     sino
            si tipo1 y tipo2 son iguales a numérico entonces
                tipo = lógico
            sino
                tipo = tipo inválido

funcion tipoComparaciónIgualdad(tipo1,tipo2)
     si tipo1 o tipo2 es igual a tipo inválido entonces
           tipo = tipo inválido
     sino
            tipo = lógico

 funcion tipoOperaciónLógica(tipo1,tipo2)
       si tipo1 o tipo2 es igual a tipo inválido entonces
             tipo = tipo inválido
       sino
             si tipo1 y tipo2 son iguales a booleano entonces
                 tipo = tipo1
             sino
                 tipo = tipo inválido

 funcion tipoSeqElementos(tipos)
       si algún elemento en tipos es tipo inválido o secuencia entonces
            tipo = tipo inválido
       sino
            si todos los elementos son numéricos entonces
                tipo = secuencia numérica
            en otro caso si todos los elementos son lógicos entonces
                tipo = secuencia lógica
            sino
                tipo = tipo inválido

 funcion tipoElementoDeSecuencia(expr_sacar_elem)
      identificador = sacar de expr_sacar_elem nombre identificador
      tipo = tipoVariable(identificador)



