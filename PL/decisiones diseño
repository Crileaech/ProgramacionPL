DECISIONES DE DISEÑO error 1 (error asignación):

    (DECISIÓN 1.1)
       Para saber si una asignación está bien tipada necesitamos un almacén que contenga información acerca del tipo de las variables declaradas.
       De este modo, cuando se produzca una asignación podremos comprobar si el valor asignado a dicha variable concuerda con el tipo registrado
       en el almacén.

       Almacén de variables globales (programa): (en el caso de comprobar asignaciones de subprogramas tendremos que mirar el almacén correspon-
                                                   diente en el almacén de subprogramas -> Ver decisión 2.1)
           variables   |    tipos
        --------------------------------------
            seq        |    Secuencia numérica
            i          |    Numérico
            loEs       |    Lógico


       programa: PROGRAMA n=variables {almacenar n en almacén} subprogramas instrucciones EOF;

       (parámetro de salida n)
       variables: VARIABLES (m=declaracion_variables {almacenar m en n})*;

       (parámetro de salida m)
       declaracion_variables: (r,t)=identificador PyC; {Almacenar en m cada variable en r con tipo t}

       (parámetro de salida (r,t))
       identificador: elementales
                    | secuencias
                    ;

       (parámetro de salida (r,t))
       elementales: (VAR {incluir VAR en r} COMA)* VAR {incluir VAR en r} DOSPTOS t=tipos_elementales {incluir r y t en (r,t)};

       (parámetro de salida (r,t))
       secuencias: VAR {incluir VAR en r} DOSPTOS t=tipos_no_elementales {incluir r_y_t en unión};

       (parámetro de salida t)
       tipos: tipos_elementales
            | tipos_no_elementales
            ;

       tipos_elementales: NUMERO {t=numero}
                        | BOOL {t=lógico}
                        ;

       tipos_no_elementales: SEQ_NUM {t=secuencia numérica}
                           | SEQ_BOOL {t=secuencia lógica}
                           ;
    (DECISIÓN 1.2)
    Una asignación está bien tipada sí y solo sí el tipo de la variable coincide con el tipo de la expresión asignada.

    funcion comprobarTiposAsignación(tipo_var, tipo_expr)
        si tipo expr es igual a tipo invalido
            error
        sino
            si tipo_var es igual a tipo_expr entonces
                no error
            sino
                error

    funcion comprobaciónTiposAsignaciones(tipo_vars, tipo_exprs) //para asignaciones múltiples.
        almacen n
        pares = pares_var_expr(tipo_vars, tipo_exprs)
        para cada par en pares:
            añado en n comprobarTiposAsignación(tipo_var en par, tipo_expr en par)
        si en n no error entonces
            no error
        sino
            error

    (DECISIÓN 1.3)
    El cálculo del tipo de una expresión se basa en las siguientes funciones.

    funcion tipoOperaciónNumérica(tipo1,tipo2)
          si tipo1 o tipo2 es igual a tipo inválido entonces
                tipo = tipo inválido
          sino
                si tipo1 es igual a tipo2 entonces //no hay que mirar si tipo1 o tipo2 son numéricos pues ya lo comprueba el sintáctico
                    tipo = tipo1
                sino
                    tipo = tipo inválido

    funcion tipoComparaciónNumérica(tipo1,tipo2)
         si tipo1 o tipo2 es igual a tipo inválido entonces
               tipo = tipo inválido
         sino
                si tipo1 y tipo2 son iguales entonces //no hay que mirar si tipo1 o tipo2 son numéricos pues ya lo comprueba el sintáctico
                    tipo = lógico
                sino
                    tipo = tipo inválido

    funcion tipoComparaciónIgualdad(tipo1,tipo2)
         si tipo1 o tipo2 es igual a tipo inválido entonces
               tipo = tipo inválido
         sino
                tipo = lógico

     funcion tipoOperaciónLógica(tipo1,tipo2)
           si tipo1 o tipo2 es igual a tipo inválido entonces
                 tipo = tipo inválido
           sino
                 si tipo1 y tipo2 son iguales entonces
                     tipo = tipo1
                 sino
                     tipo = tipo inválido

     funcion tipoSeqElementos(tipos)
           si algún elemento en tipos es tipo inválido o secuencia entonces
                tipo = tipo inválido
           sino
                si todos los elementos son numéricos entonces
                    tipo = secuencia numérica
                en otro caso si todos los elementos son lógicos entonces
                    tipo = secuencia lógica
                sino
                    tipo = tipo inválido

    (DECISIÓN 1.4)
    El cálculo del tipo de una expresión se basa en las siguientes funciones.

    funcion tipoOperaciónNumérica(tipo1,tipo2)
          si tipo1 o tipo2 es igual a tipo inválido entonces
                tipo = tipo inválido
          sino
                si tipo1 y tipo2 son numéricos entonces
                    tipo = tipo1
                sino
                    tipo = tipo inválido

    funcion tipoComparaciónNumérica(tipo1,tipo2)
         si tipo1 o tipo2 es igual a tipo inválido entonces
               tipo = tipo inválido
         sino
                si tipo1 y tipo2 son iguales a numérico entonces
                    tipo = lógico
                sino
                    tipo = tipo inválido

    funcion tipoComparaciónIgualdad(tipo1,tipo2)
         si tipo1 o tipo2 es igual a tipo inválido entonces
               tipo = tipo inválido
         sino
                tipo = lógico

     funcion tipoOperaciónLógica(tipo1,tipo2)
           si tipo1 o tipo2 es igual a tipo inválido entonces
                 tipo = tipo inválido
           sino
                 si tipo1 y tipo2 son iguales a booleano entonces
                     tipo = tipo1
                 sino
                     tipo = tipo inválido

     funcion tipoSeqElementos(tipos)
           si algún elemento en tipos es tipo inválido o secuencia entonces
                tipo = tipo inválido
           sino
                si todos los elementos son numéricos entonces
                    tipo = secuencia numérica
                en otro caso si todos los elementos son lógicos entonces
                    tipo = secuencia lógica
                sino
                    tipo = tipo inválido

     funcion tipoElementoDeSecuencia(expr_sacar_elem)
          identificador = sacar de expr_sacar_elem nombre identificador
          tipo = tipoVariable(identificador)


    funcion tipoVariable(identificador)
        si identificador en almacen(=n) global:
            tipo = n[identificador]
        en otro caso si estamos en función:
            almacenFuncion = extraer de almacen de funciones (=k) el almacen de la funcion(=[PARAM(...), DEV(...), CUERPO(...)]
            tipo = tipo inválido //si no se haya en ningun lugar declarada la variable entonces no tiene tipo
            para cada subAlmacen en almacenFuncion:
                si identificador en subAlmacen:
                    tipo = subAlmacen[identificador]
                    fin
        sino:
            tipo = tipo inválido

    funcion tipoFuncion(expr_func)
        almacenFuncion = extraer de k el almacen de la funcion
        tipo = almacenFuncion[DEV] //tipo sería una colección de los tipos devueltos por la función.

DECISIONES DE DISEÑO error 2 (error asignación a parámetros de subprograma expresiones con tipo no válido):

    (DECISIÓN 2.1)
        Para saber si las asignaciones sobre los parámetros de subprogramas son adecuadas necesitamos de un almacén
        que contenga tantas entradas como subprogramas tenga nuestro programa.
        Por cada una de estas entradas nos encontraremos con un almacén que contiene las variables y tipos de
        dicho subprograma, dividiéndose en tres categorías: PARAM (las que se esperan recibir como parámetros), DEV
        (las que se esperan devolver) y CUERPO (las declaradas en variables).

         Almacén k de variables de subprogramas:
         ------------------------------------------------------------
         func1   |      PARAM             DEV             CUERPO
         (f1)    |---------------------------------------------------
                 |variables tipos | variables tipos | variables tipos
                 |
                 |
         ------------------------------------------------------------
         func2   |      PARAM             DEV             CUERPO
         (f2)    |---------------------------------------------------
                 |variables tipos | variables tipos | variables tipos
                 |
                 |
          .
          .
         (fn) n=num de funciones

         programa: PROGRAMA variables k=subprogramas instrucciones EOF;

         (parámetro de salida k)
         subprogramas: SUBPROGRAMAS (f=declaracion_subprogramas {almacena f en k})*;

         (parámetro de salida f)
         declaracion_subprogramas: funcion
                                 | procedimiento
                                 ;

         (parámetro de salida f)
         funcion: FUNCION variable PA (PARAM=params)? PC RETURN PA DEV=params PC CUERPO=variables instrucciones FFUNCION;
        {Almacena en f PARAM, DEV y CUERPO}

        (parámetro de salida f)
         procedimiento: PROCEDIMIENTO variable PA (PARAM=params)? PC CUERPO=variables instrucciones FPROCEDIMIENTO;
        {Almacena en f PARAM, DEV (vacío) y CUERPO}

        (parámetro de salida PARAM o DEV)
         params: t=tipos r=variable {Almacena en PARAM o DEV t y r}
               | t=tipos r=variable COMA params {Almacena en PARAM o DEV t y r} //recursividad revisar
               ; (obtención de m vista en la decisión de diseño del error 1)

         (parámetro de salida CUERPO)
         variables: VARIABLES (m=declaracion_variables)*; {Almacena en CUERPO m}
         ... (obtención de m vista en la decisión de diseño del error 1)

    (DECISIÓN 2.2)
    Una asignación de una expresión sobre un parámetro a función está bien tipada sí y solo sí el tipo de dicha
    expresión coincide con el tipo del parámetro.

    función comprobarAsignaciónAParámetro(tipo_parametro, tipo_expr)
           si tipo_parametro es igual a tipo_expr entonces
               no error
           sino
               error

    función comprobarAsignacionesAParámetros(tipo_parametros, tipo_exprs)
           almacen n
           pares = pares_var_expr(tipo_parametros, tipo_exprs)
           para cada par en pares:
               añado en n comprobarAsignaciónAParámetro(tipo_param en par, tipo_expr en par)
           si en n no error entonces
               no error
           sino
               error

DECISIONES DE DISEÑO error 3 (error por devolución de tipos distintos a indicados en cabecera de subprograma):

    (DECISIÓN 3.1)
    Una devolución es errónea si el tipo de los elementos devueltos no coincide con los tipos de los elementos a
    devolver por orden o bien porque el número de elementos devueltos no coincide con el número de los indicados
    en la cabecera.

    función comprobarDevolucion(tipo_devuelto, tipo_aDevolver)
           si tipo_devuelto es igual a tipo_aDevolver entonces
               no error
           sino
               error

    función comprobarAsignacionesAParámetros(tipos_devueltos, tipos_aDevolver)
           almacen n
           pares = pares_var_expr(tipos_devueltos, tipos_aDevolver)
           para cada par en pares:
               añado en n comprobarDevolucion(tipo_devuelto en par, tipo_aDevolver en par)
           si en n no error entonces
               no error
           sino
               error

